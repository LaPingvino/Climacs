\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename climacs-internals
@settitle Climacs Internals
@c %**end of header

@copying
The Climacs Internals manual

Copyright @copyright{} 2004 Robert Strandh.

@end copying

@titlepage
@title Climacs Internals

@sp 5
@center @titlefont{Essential Protocols}
@sp 2
@center @titlefont{and}
@sp 2
@center @titlefont{Implementation Hints}
@sp 2
@author Robert Strandh

@page
@vskip 0pt plus 1filll
@insertcopying

@end titlepage

@contents

@alias glossentry = b

@alias gloss = t
@alias class = t
@alias genfun = t
@alias mac = t
@alias gadget = t
@alias pane = t
@alias initarg = t
@alias methcomp = t
@alias slot = t
@alias cl = t

@chapter Introduction

You are reading the Climacs internals manual.  This document contains
a detailed description of various Climacs protocols. 

@chapter Buffer protocol

@section Introduction

The Climacs buffer is what holds textual and other objects to be
edited and displayed.  Conceptually, the buffer is a potentially
large sequence of objects, most of which are expected to be
characters (the full Unicode character set is supported).  However,
Climacs buffers can contain any Common Lisp objects, as long as the
syntax module knows how to render them. 

The Climacs  buffer implementation differs from that of a vector,
because it allows for very efficient editing operations, such as
inserting and removing objects at arbitrary offsets. 

In addition, the Climacs buffer protocols defines that concept of a
mark.

@section General

@deftp {Protocol Class} buffer

The base class for all buffers.  A buffer conceptually contains a
large array of arbitrary objects.  Lines of objects are separated by
newline characters.  The last object of the buffer is not
necessarily a newline character.
@end deftp

@deftp {Class} standard-buffer

The standard instantiable class for buffers.  A subclass of buffer.
@end deftp

@deftp {Protocol Class} mark

The base class for all marks. 
@end deftp

@deftp {Initarg} :buffer

The :buffer initarg is mandatory because no mark can exist without a
buffer.  When the :offset initarg is not given, it defaults to zero.
@end deftp

@deftp {Initarg} :offset

If an :offset initarg is given that is less than zero or greater than
the size of the buffer, a no-such-offset condition is signaled. 
@end deftp

@deftp {Protocol Class} left-sticky-mark

A subclass of mark.  A mark of this type will "stick" to the object
to the left of it, i.e. when an object is inserted at this mark, the
mark will be positioned to the left of the object.
@end deftp

@deftp {Protocol Class} right-sticky-mark

A subclass of mark.  A mark of this type will "stick" to the object
to the right of it, i.e. when an object is inserted at this mark, the
mark will be positioned to the right of the object.
@end deftp

@deffn {Generic Function} {clone-mark} (mark &key type)

Clone a mark.  By default (when type is NIL) the same type of mark is
returned.  Otherwise type is the name of a class (subclass of the mark
class) to be used as a class of the clone. 
@end deffn

@deffn {Generic Function} {buffer} mark

Return the buffer that the mark is positioned in.
@end deffn

@deftp {Error Condition} no-such-offset

This condition is signaled whenever an attempt is made at an operation
that is before the beginning or after the end of the buffer. 
@end deftp

@deffn {Generic Function} {size} buffer

Return the number of objects in the buffer.  
@end deffn

@deffn {Generic Function} {number-of-lines} buffer

Return the number of lines of the buffer, or really the number of
newline characters.  
@end deffn

@section Operations related to the offset of marks


@deffn {Generic Function} {offset} mark

Return the offset of the mark into the buffer.
@end deffn

@deffn {Generic Function} {(setf offset)} offset mark

Set the offset of the mark into the buffer.  A no-such-offset
condition is signaled if the offset is less than zero or greater than
the size of the buffer. 
@end deffn

@deffn {Generic Function} {mark<} mark1 mark2

Return t if the offset of mark1 is strictly less than that of mark2.
An error is signaled if the two marks are not positioned in the same
buffer.  It is acceptable to pass an offset in place of one of the
marks. 
@end deffn

@deffn {Generic Function} {mark<=} mark1 mark2

Return t if the offset of mark1 is less than or equal to that of
mark2.  An error is signaled if the two marks are not positioned in
the same buffer.  It is acceptable to pass an offset in place of one
of the marks.
@end deffn

@deffn {Generic Function} {mark>} mark1 mark2

Return t if the offset of mark1 is strictly greater than that of
mark2.  An error is signaled if the two marks are not positioned in
the same buffer.  It is acceptable to pass an offset in place of one
of the marks.
@end deffn

@deffn {Generic Function} {mark>=} mark1 mark2

Return t if the offset of mark1 is greater than or equal to that of
mark2.  An error is signaled if the two marks are not positioned in
the same buffer.  It is acceptable to pass an offset in place of one
of the marks.
@end deffn

@deffn {Generic Function} {mark=} mark1 mark2

Return t if the offset of mark1 is equal to that of mark2.  An error
is signaled if the two marks are not positioned in the same buffer.
It is acceptable to pass an offset in place of one of the marks.
@end deffn

@deffn {Generic Function} {beginning-of-buffer} mark

Move the mark to the beginning of the buffer.  This is equivalent to
(setf (offset mark) 0)
@end deffn

@deffn {Generic Function} {end-of-buffer} mark

Move the mark to the end of the buffer.
@end deffn

@deffn {Generic Function} {beginning-of-buffer-p} mark

Return t if the mark is at the beginning of the buffer, nil
otherwise. 
@end deffn

@deffn {Generic Function} {end-of-buffer-p} mark

Return t if the mark is at the end of the buffer, nil otherwise.
@end deffn

@deffn {Generic Function} {beginning-of-line} mark

Move the mark to the beginning of the line.  The mark will be
positioned either immediately after the closest preceding newline
character, or at the beginning of the buffer if no preceding newline
character exists. 
@end deffn

@deffn {Generic Function} {end-of-line} mark

Move the mark to the end of the line. The mark will be positioned
either immediately before the closest following newline character, or
at the end of the buffer if no following newline character exists. 
@end deffn

@deffn {Generic Function} {beginning-of-line-p} mark

Return t if the mark is at the beginning of the line (i.e., if the
character preceding the mark is a newline character or if the mark is
at the beginning of the buffer), nil otherwise.
@end deffn

@deffn {Generic Function} {end-of-line-p} mark

Return t if the mark is at the end of the line (i.e., if the character
following the mark is a newline character, or if the mark is at the
end of the buffer), nil otherwise.
@end deffn

@deffn {Generic Function} {line-number} mark

Return the line number of the mark.  Lines are numbered from zero.
@end deffn


@deffn {Generic Function} {column-number} mark

Return the column number of the mark. The column number of a mark is
the number of objects between it and the preceding newline, or
between it and the beginning of the buffer if the mark is on the
first line of the buffer.
@end deffn


@section Inserting and deleting objects

@deffn {Generic Function} {insert-buffer-object} buffer offset object

Insert the object at the offset in the buffer.  Any left-sticky marks
that are placed at the offset will remain positioned before the
inserted object.  Any right-sticky marks that are placed at the
offset will be positioned after the inserted object.
@end deffn

@deffn {Generic Function} {insert-buffer-sequence} buffer offset sequence

Like calling insert-buffer-object on each of the objects in the
sequence.
@end deffn

@deffn {Generic Function} {insert-object} mark object

Insert the object at the mark.  This function simply calls
insert-buffer-object with the buffer and the position of the mark. 
@end deffn

@deffn {Generic Function} {insert-sequence} mark sequence

Insert the objects in the sequence at the mark. This function simply
calls insert-buffer-sequence with the buffer and the position of the
mark.
@end deffn

@deffn {Generic Function} {delete-buffer-range} buffer offset n
                  
Delete n objects from the buffer starting at the offset.  If offset
is negative or offset+n is greater than the size of the buffer, a
no-such-offset condition is signaled.
@end deffn

@deffn {Generic Function} {delete-range} mark &optional (n 1)

Delete n objects after (if n > 0) or before (if n < 0) the mark.
This function eventually calls delete-buffer-range, provided that n
is not zero.
@end deffn

@deffn {Generic Function} {delete-region} mark1 mark2

Delete the objects in the buffer that are
between mark1 and mark2.  An error is signaled if the two marks
are positioned in different buffers.  It is acceptable to pass an
offset in place of one of the marks.

This function calls delete-buffer-range with the appropriate arguments.
@end deffn

@section Getting objects out of the buffer

@deffn {Generic Function} {buffer-object} buffer offset

Return the object at the offset in the buffer.  The first object
has offset 0. If offset is less than zero or greater than or equal to
the size of the buffer, a no-such-offset condition is signaled.
@end deffn

@deffn {Generic Function} {buffer-sequence} buffer offset1 offset2

Return the contents of the buffer starting at offset1 and ending at
offset2-1 as a sequence.  If either of the offsets is less than zero
or greater than or equal to the size of the buffer, a no-such-offset
condition is signaled.  If offset2 is smaller than or equal to
offset1, an empty sequence will be returned.
@end deffn

@deffn {Generic Function} {objecct-before} mark

Return the object that is immediately before the mark.  If mark is at
the beginning of the buffer, a no-such-offset condition is signaled.
If the mark is at the beginning of a line, but not at the beginning
of the buffer, a newline character is returned.
@end deffn

@deffn {Generic Function} {objecct-after} mark

Return the object that is immediately after the mark.  If mark is at
the end of the buffer, a no-such-offset condition is signaled.  If
the mark is at the end of a line, but not at the end of the buffer, a
newline character is returned.
@end deffn

@deffn {Generic Function} {region-to-sequence} mark1 mark2

Return a freshly allocated sequence of the objects after mark1 and
before mark2.  An error is signaled if the two marks are positioned
in different buffers.  If mark1 is positioned at an offset equal to
or greater than that of mark2, an empty sequence is returned.  It is
acceptable to pass an offset in place of one of the marks.
@end deffn

@section Implementation hints

The buffer is implemented as lines organized in a 2-3-tree.  The
leaves of the tree contain the lines, and the internal nodes contain
additional information of the left subtree (if it is a 2-node) or the
left and the middle subtree (if it is a 3-node).  Two pieces of
information are stored: The number of lines in up to and including
the subtree and the total number of objects up to an including the
subtree.  This organization allows us to determine, the line number
and object position of any mark in O(log N) where N is the number of
lines.

A line is an instance of the `buffer-line' class.  A line can either
be open or closed.  A closed line is represented as a sequence.  The
exact type of the sequence depends on the objects contained in the
line.  If the line contains only characters of type base-char, then
the sequence is of type base-string.  If the line contains only
characters, but not of type base-char, the sequence is a string.
Otherwise it is a vector of arbitrary objects.  This way, closed
lines containing characters with code points below 256 have a compact
representation with 8 bits per character while still allowing for
arbitrary objects when necessary.  An open line is represented as a
cursorchain of objects. 

Marks in a closed line are represented as an integer offset into the
sequence.  Marks in an open line are represented as flexicursors.

When a line is opened, it is converted to a cursorchain.  When a line
is closed, it is examined to determine whether it contains
non-character objects, in which case it is converted to a vector of
objects.  If contains only characters, but it contains characters
with code points above what can be represented in a base-char, it is
converted to a string.  If it contains only base-chars, it is
converted to a base-string.

A mark contains two slots: a flexicursor that determines which line it
is on, and either an integer (if the line is closed) that determines
the offset within the line or another flexicursor (if the line is
open).  For each line, open or closed, a list of weak references to
marks into that line is kept.  

Lines are closed according to a LRU scheme.  Whenever objects are
inserted to or deleted from a line, it becomes the most recently used
line.  We keep a fixed number of open lines so that when a line is
opened and the threshold is reached, the least recently used line is
closed.

@chapter The buffer modification protocol

The buffer maintains two marks, the low mark and the high mark:

@deffn {Generic Function} {low-mark} buffer

Return the low mark of the buffer.
@end deffn

@deffn {Generic Function} {high-mark} buffer

Return the high mark of the buffer.
@end deffn

The low mark is a left-sticky mark and high mark is a right-sticky
mark.  Whenever a modification is made to the buffer, the offset of
the low mark is set to the minimum of its current value and the
position of the modification.  Similarly, whenever a modification is
made to the buffer, the offset of the high mark is set to the maximum
of its current value and the position of the modification.

The redisplay module may use these values to determine what part of
the screen needs to be updated.  These values can also be used to
update information about syntax highlighting and other cached
information.

In addition to these marks, the buffer maintains a modification flag
that determines.  Whether the buffer has been modified since the last
call to clear-modify. 

@deffn {Generic Function} {modified-p} buffer

Return true if and only if the buffer has beeen modified. 
@end deffn

@deffn {Generic Function} {clear-modify} buffer

Set the high-mark to the beginning of the beginning of the buffer and
the low-mark to the end of the buffer, and clear the modification
flag. 
@end deffn

This function is used by the redisplay module after all of the panes
on display have been redisplayed properly.  A call to this function
concludes the interaction loop and Climacs is again ready to read and
execute commands. 

@chapter The climacs-base package

@section Purpose 

The buffer protocol has been designed to be reasonably efficient with
a variety of different implementation strategies (single gap buffer or
sequence of independent lines).  It contains (and should only contain)
the absolute minimum of functionality that can be implemented
efficiently independently of strategy.  However, this minimum of
functionality is not always convenient.

The purpose of the climacs-base package is to implement additional
functionality on top of the buffer protocol, in a way that does not
depend on how the buffer protocol was implemented.  Thus, the
climacs-base package should remain intact across different
implementation strategies of the buffer protocol.  

Achieving portability of the climacs-base package is not terribly hard
as long as only buffer protocol functions are used.  What is slightly
harder is to be sure to maximize efficiency across several
implementation strategies.  The next section discusses such
considerations and gives guidelines to implementers of additional
functionality. 

Implementers of the buffer protocol may use the contents of the next
section to make sure they respect the efficiency considerations that
are expected by the climacs-base package. 

@section Efficiency considerations 

In this section, we give a list of rules that implementors of
additional functionality should follow in order to make sure that such
functionality remains efficient (in addition to being portable) across
a variety of implementation strategies of the buffer protocol.  

@quotation Rule
Comparing the position of two marks is efficient, i.e. at most O(log
n) where n is the number of marks in the buffer (which is expected to
be very small compared to the number of objects) in all
implementations.  This is true for all types of comparisons.
@end quotation

It is expected that marks are managed very efficiently.  Some balanced
tree management might be necessary, which will make operations have
logarithmic complexity, but only in the number of marks that are
actually used. 

@quotation Rule
While computing and setting the offset of a mark is fairly efficient,
it is not guaranteed to be O(1) even though it might be in an
implementation using a single gap buffer.  It might have a complexity
of O(log n) where n is the number of lines in the buffer.  This is
true for using incf on the offset of a mark as well, as incf expands
to a setf of the offset.  

Do not hesitate computing or setting the offset of a mark, but avoid
doing it in a tight loop over many objects of the buffer. 
@end quotation

@quotation Rule
Determining whether a mark is at the beginning or at the end of the
buffer is efficient, i.e. O(1), in all implementations.
@end quotation

@quotation Rule
Determining whether a mark is at the beginning or at the end of a line
is efficient, i.e. O(1), in all implementations. 
@end quotation

@quotation Rule
Going to the beginning or to the end of a line might have linear-time
complexity in the number of characters of the line, though it is
constant-time complexity if the implementation is line oriented.  

It is sometimes inevitable to use this functionality, and since lines
are expected to be short, it should not be avoided at all cost,
especially since it might be very efficient in some implementations.
We do recommend, however to avoid it in tight loops. 

Always use this functionality rather than manually incrementing the
offset of a mark in a loop until a Newline character has been found,
especially since each iteration might take logarithmic time then.
@end quotation

@quotation Rule
Computing the size of the buffer is always efficient, i.e., O(1). 
@end quotation

@quotation Rule
Computing the number of lines of the buffer is always efficient, i.e.,
O(1). 
@end quotation

Implementations of the buffer protocol could always track the number
of insertions and deletions of objects, so there is no reason why this
operation should be inefficient. 

@quotation Rule
Computing the line number of a mark or of an offset can be very
costly, i.e. O(n) where n is size of the buffer.
@end quotation

This operation is part of the buffer protocol because some
implementations may implement it fairly efficiently, say O(log n)
where n is the number of lines in the buffer.

@chapter Redisplay and the syntax protocol 

@section General

A buffer can be on display in several panes.  The redisplay
algorithm is invoked on each such pane.  Each pane is associated
with a distinguished mark called the `point' of the pane.  The point
is a right-sticky mark independently of whether you are typing
left-to-right or right-to-left.

The redisplay function works by dispatching on an object of type
syntax, which determines exactly how the buffer contents is going to
be rendered in this particular pane. 

@deftp {Protocol Class} syntax

The base class for all syntaxes.  

A syntax object is a placeholder for many kinds of information
depending on the exact syntax, but in particular, it holds information
(in the form of two marks) about what part of the buffer was on
display after the previous invocation of the redisplay algorithm.
@end deftp

@deftp {:initarg} :pane
Indicates the pane where rendering is to take place. 
@end deftp

All subclasses of the syntax class must support the :pane initarg.
The pane that is passed as an initarg must have a valid buffer
associated with it. 

@deffn {Function} {redisplay-pane} pane

This function is called by the command loop on every pane that is on
display.  It simply calls redisplay-with-syntax with the pane and the
syntax of the pane.  
@end deffn

@deffn {Generic Function} {redisplay-with-syntax} pane syntax

Redisplay a pane using a given syntax.  
@end deffn

This function can behave radically differently for different syntaxes.
In all cases, however, it starts by determining the current dimensions
of the pane, and compare that to the size of the region of the buffer
that is currently on display.  Adjustments are made as necessary.  It
then determines whether the point of the pane is within the region on
display.  If not, a new region is computed in a way that the point is
as close to the middle of the pane as possible.  It is important to
maintain the region on display as much as possible, so as to avoid
unnecessary scrolling. 

The final step of this function is to render the region of the buffer
that is to be displayed.  Some syntaxes can use simple algorithms that
simply draw everything in the region.  Others can optimize so that
only the portions of the pane that have actually changed are redrawn.

The redisplay-with-syntax function also implements parsing of the
buffer text.  

Simple parsers may be restricted to dividing the text into words,
possibly recognizing special words like URLs or email addresses, and
then using `present' to render these words.

More complicated parsers may use incremental parsing techniques to
maintain sophisticated information of the buffer contents.  Such a
parser needs to use the low-mark and high-mark to determine which
parts of the buffer have changed, and recompute parsing information as
necessary. 

@section Common Lisp syntax

Technically, comments and such are not expressions, but it is OK for
our purposes to consider that they are.

@multitable @columnfractions .2 .1 .5
@item program @tab -> @tab expr*
@item expr @tab -> @tab quoted-expression
@item expr @tab -> @tab comment
@item expr @tab -> @tab string
@item expr @tab -> @tab backquote-expression
@item expr @tab -> @tab unquote-expression
@item expr @tab -> @tab list-expression
@item expr @tab -> @tab label-ref
@item expr @tab -> @tab function-expression
@item expr @tab -> @tab vector-expression
@item expr @tab -> @tab array-expression
@item expr @tab -> @tab bitvector-expression
@item expr @tab -> @tab labeled-expression
@item expr @tab -> @tab character
@item expr @tab -> @tab balanced-comment
@item expr @tab -> @tab read-time-conditional-+
@item expr @tab -> @tab read-time-conditional--
@item expr @tab -> @tab read-time-evaluation
@item expr @tab -> @tab binary-expression
@item expr @tab -> @tab complex-expression
@item expr @tab -> @tab octal-expression
@item expr @tab -> @tab pathname-expression
@item expr @tab -> @tab radix-n-expression
@item expr @tab -> @tab hex-expression
@item expr @tab -> @tab token
@end multitable

@multitable @columnfractions .3 .3 .3
@item Expression @tab Syntax @tab handle/read
@item quoted-expression @tab 'expr  @tab handle
@item comment @tab ; chars <newline> @tab handle
@item string @tab " chars " @tab read
@item backquote-expression @tab ` expr @tab handle
@item unquote-expression @tab , expr @tab handle
@item list-expression @tab ( expr* ) @tab handle
@item label-ref @tab #n# @tab handle
@item function-expression @tab #' expr @tab handle
@item vector-expression @tab #( expr* ) @tab handle
@item array-expression @tab #nA(...) @tab handle
@item bitvector-expression @tab #* bits @tab read
@item labeled-expression @tab #n= @tab handle
@item character @tab #\.. @tab read
@item balanced-comment @tab #| .. |# @tab handle
@item read-time-conditional-+ @tab #+test expr @tab handle
@item read-time-conditional-- @tab #-test expr @tab handle
@item read-time-evaluation @tab #.expr @tab handle
@item binary-expression @tab #b... @tab read
@item complex-expression @tab #c... @tab read
@item octal-expression @tab #o... @tab read
@item pathname-expression @tab #p... @tab read
@item radix-n-expression @tab #nr @tab read
@item hex-expression @tab #x @tab read
@end multitable

@deftp {class} stack-entry

A stack entry corresponds to a syntactic category and contains a
start offset and an end offset.  The end offset is initialized to
nil, meaning we do not know where it ends.
@end deftp

@deftp {initarg} :start-offset
@end deftp

@deftp {class} error-entry

This is a subclass of stack-entry.  It is used whenever some invalid
input syntax is encountered. 
@end deftp

@deftp {class} terminal-entry

This is a subclass of stack-entry.  It is used for tokens (numbers,
symbols), but also for macro characters that start more complex
expressions. 
@end deftp

@deftp {class} number-entry

A subclass of terminal-entry corresponding to the syntactic class of
numbers. 
@end deftp

@deftp {class} symbol-entry

A subclass of terminal-entry corresponding to the syntactic class of
symbols. 
@end deftp

@deftp {class} character-entry

A subclass of terminal-entry corresponding to the syntactic class of
characters. 
@end deftp

@deftp {class} string-entry

A subclass of terminal-entry corresponding to the syntactic class of
character strings 
@end deftp

@deftp {class} quote-entry

A subclass of terminal-entry corresponding to the syntactic class of
quote inidicators.
@end deftp

@deftp {class} backquote-entry

A subclass of terminal-entry corresponding to the syntactic class of
backquote indicators. 
@end deftp

@deftp {class} unquote-entry

A subclass of terminal-entry corresponding to the syntactic class of
unquote indicators. 
@end deftp

@deftp {class} comment-entry

A subclass of terminal-entry corresponding to the syntactic class of
single-line comment indicators. 
@end deftp

@deftp {class} list-start-entry

A subclass of terminal-entry corresponding to the syntactic class of
list start indicators.
@end deftp

@deftp {class} list-end-entry

A subclass of terminal-entry corresponding to the syntactic class of
list end indicators.
@end deftp

@deftp {class} label-ref-entry

A subclass of terminal-entry corresponding to the syntactic class of
label reference indicators.
@end deftp

@deftp {class} label-entry

A subclass of terminal-entry corresponding to the syntactic class of
label indicators.
@end deftp

@deftp {class} function-entry

A subclass of terminal-entry corresponding to the syntactic class of
function indicators.
@end deftp

@deftp {class} balanced-comment-entry

A subclass of terminal-entry corresponding to the syntactic class of
balanced comment entry indicators. 
@end deftp

@deftp {class} read-time-conditional-entry

A subclass of terminal-entry corresponding to the syntactic class of
read-time conditional indicators. 
@end deftp

@deftp {class} vector-entry

A subclass of terminal-entry corresponding to the syntactic class of
vector indicators.
@end deftp

@deftp {class} array-entry

A subclass of terminal-entry corresponding to the syntactic class of
array indicators.
@end deftp

@deftp {class} bitvector-entry

A subclass of terminal-entry corresponding to the syntactic class of
bit vector indicators. 
@end deftp

@deftp {class} read-time-evaluation-entry

A subclass of terminal-entry corresponding to the syntactic class of
read-time evaluation indicators. 
@end deftp

@deftp {class} complex-entry

A subclass of terminal-entry corresponding to the syntactic class of
complex indicators.
@end deftp

@deftp {class} octal-entry

A subclass of terminal-entry corresponding to the syntactic class of
octal rational indicators.
@end deftp

@deftp {class} hex-entry

A subclass of terminal-entry corresponding to the syntactic class of
hex rational indicators.
@end deftp

@deftp {class} radix-n-entry

A subclass of terminal-entry corresponding to the syntactic class of
radix-n rational indicators.
@end deftp

@deftp {class} pathname-entry

A subclass of terminal-entry corresponding to the syntactic class of
pathname indicators.
@end deftp

@deftp {class} binary-entry

A subclass of terminal-entry corresponding to the syntactic class of
binary rational indicators.
@end deftp

@deftp {class} unknown-entry

A subclass of terminal-entry corresponding to unknown (user-defined)
syntactic classes. 
@end deftp

@deftp {class} nonterminal-entry

This is a subclass of stack-entry.  A nonterminal entry maintains an
expression count, which is initialized to 0.  It corresponds to the
number of subexpressions of this expression that have been detected. 
A nonterminal entry also maintains a backquote-depth which is
initially 0, is incremented by 1 for each nested backquote, and is
decremented by 1 for each comma.
@end deftp

@deffn {generic function} expression-count nonterminal-entry

Return the expression count of this entry. 
@end deffn

@deffn {generic function} {(setf expression-count)} count nonterminal-entry

Set the expression count of this entry.
@end deffn

@deffn {generic function} backquote-depth nonterminal-entry

Return the backquote-depth of this entry.
@end deffn

@deffn {generic function} {(setf backquote-depth)} depth nonterminal-entry

Set the backquote-depth of this entry.
@end deffn

@deftp {class} program-entry

A subclass of nonterminal-entry corresponding to the entire buffer
contents. 
@end deftp

@deftp {class} quoted-expression-entry

A subclass of nonterminal-entry corresponding to a quoted
expression. 
@end deftp

@deftp {class} unquoted-expression-entry

A subclass of nonterminal-entry corresponding to an unquoted
expression.
@end deftp

@deftp {class} list-expression-entry

A subclass of nonterminal-entry corresponding to a list expression. 
@end deftp

@deftp {class} function-expression-entry

A subclass of nonterminal-entry corresponding to a function
expression. 
@end deftp

@deftp {class} vector-expression-entry

A subclass of nonterminal-entry corresponding to a vector expression.
@end deftp

@deftp {class} labeled-expression-entry

A subclass of nonterminal-entry corresponding to a labeled expression. 
@end deftp

@deftp {class} array-expression-entry

A subclass of nonterminal-entry corresponding to a list expression. 
@end deftp

@deftp {class} array-dimension-entry

A subclass of nonterminal-entry corresponding to an array dimension. 
@end deftp

@deftp {class} read-time-feature-entry

A subclass of nonterminal-entry corresponding to a read-time
feature. 
@end deftp

@deftp {class} read-time-conditional-expression-entry

A subclass of nonterminal-entry corresponding to a read-time
conditional expression. 
@end deftp

@deftp {class} read-time-evaluation-expression-entry

A subclass of nonterminal-entry corresponding to a read-time
evaluation expression. 
@end deftp

@deftp {class} complex-expression-entry

A subclass of nonterminal-entry corresponding to a complex
expression. 
@end deftp

@deftp {class} octal-expression-entry

A subclass of nonterminal-entry corresponding to an octal expression.
@end deftp

@deftp {class} hex-expression-entry

A subclass of nonterminal-entry corresponding to a hexadecimal
expression.
@end deftp

@deftp {class} radix-n-expression-entry

A subclass of nonterminal-entry corresponding to a radix-n
expression. 
@end deftp

@deftp {class} pathname-expression-entry

A subclass of nonterminal-entry corresponding to a pathname
expression. 
@end deftp

@deftp {class} binary-expression-entry

A subclass of nonterminal-entry corresponding to binary expression. 
@end deftp

@deftp {class} buffer-stream

A stream corresponding to a text buffer.  It contains a current parse
stack which is a list of stack entries.
@end deftp

@deftp {initarg} :buffer

The buffer underlying the stream. 
@end deftp

@deffn {generic function} current-offset buffer-stream

Return the current offset of the buffer stream.
@end deffn

@deffn {generic function} {(setf current-offset)} offset buffer-stream

set the current offset of the buffer stream.
@end deffn

@deffn {generic function} max-offset buffer-stream

Return the maximum offset of the buffer stream, beyond which no
parsing is required.
@end deffn

@deffn {generic function} {(setf max-offset)} offset buffer-stream

set the maximum offset of the buffer stream.
@end deffn

@deffn {method} stream-read-char buffer-stream

Return the character at the current offset (or :eof if the offset is
equal to the size of the buffer)
@end deffn

@deffn {generic function} parse-stack buffer-stream

Return the current parse stack of the buffer stream.  The parse stack
contains either all nonterminal, or all but the top element
nonterminal.  The list of entries is initially a list of a single
entry corresponding to the syntactic category `program-entry' with a
start offset of 0 and an expression count of 0.
@end deffn

@deffn {generic function} {(setf parse-stack)} stack buffer-stream

Set the current parse stack of the buffer. 
@end deffn

@deffn {generic function} analysis buffer-stream

An adjustable vector each element of which is a parse stack with top
element being terminal. The vector is initially empty.
@end deffn

@deffn {generic function} invalidate-parse buffer-stream offset

Called by client code to indicate that the buffer has been altered
starting at the offset indicated.  The analysis vector of the buffer
stream is shortened to the last entry ending before or at the
offset.  The parse stack is set to the tail of the stack at the last
entry of the analysis vector. The current offset is set to the end
offset of the last entry of the analysis vector. 
@end deffn

@deffn {generic function} advance-parse buffer-stream offset

Inform the parser that it should construct a valid analysis vector up
to the offset indicated.  The redisplay module will call this
function with the highest offset of all the windows on display before
calling display-region for each window.  The algorithm is as follows:

  Set the max offset of the buffer stream to the offset passed as
  argument.  
  Loop until the current offset is greater than or equal to max
  offset (i.e., EOF on the buffer stream is reached):
    Remember the current offset
    Read a character
    If it is a whitespace, 
      do nothing
    Else if it is a single-dispatch-macro character
      Call parse-macro-character with the buffer stream, the value of
      a call to get-macro-character of the character, the
      top-element of the current parse stack, and the remembered
     offset. 
    Else
      Unread the character and call `read' on the stream. 
      Add an entry to the end of the analysis vector containing as
      start offset the remembered offset, as end offset the current
      offset after the call to read, and a stack containing the
      current parse stack with an additional entry on top
      corresponding to the item read (number, symbol, etc).
      Increment the expression count of the top of the stack.    
      Perform a count check (see below).
@end deffn

@deffn {Generic Function} parse-macro-character buffer-stream function entry o
  
This generic function is called with a buffer stream, with a function
that is returned by a call to get-macro-character, the top-entry
of the current parse stack, and a remembered offset.
@end deffn

It has a number of methods, each one specialized (using an eql
specializer) on a function returned by a call to get-macro-character
in standard syntax.  We indicate here the character itself, but it is
the associated function that is actually used. 

@table @samp
@item ) nonterminal-entry
@itemize @bullet
@item 
Add an entry at the end of the analysis vector with the current
stack augmented with an entry for `error-entry' with a start offset
of the remembered offset and an end offset of the current offset.  
@end itemize
@item ) vector-expression-entry
@itemx ) list-expression-entry
@itemx ) array-expression-entry
@itemize @bullet
@item
Set the end offset of the entry on top of the stack to the current
offset. 
@item
Pop the current stack.
@item
Increment the expression count of the top of the stack.
@item
Perform a count check (see below)
@item
Add an entry at the end of the analysis vector with the current
stack augmented with an entry for `list-end-entry' with a start
offset of the remembered offset, and an end offset of the current
offset
@end itemize

@item ) nonterminal-entry
@itemize @bullet
  Add an entry at the end of the analysis vector with the current
  stack augmented with an entry for `error-entry' with a start offset
  of the remembered offset and an end offset of the current offset.  
@end itemize

@item ) vector-expression-entry
@itemx ) list-expression-entry
@itemx ) array-expression-entry
@itemize @bullet
@item
  Set the end offset of the entry on top of the stack to the current
  offset. 
@item
  Pop the current stack.
@item
  Increment the expression count of the top of the stack.    
@item
  Perform a count check (see below).
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with an entry for `list-end-entry' with a start
  offset of the remembered offset, and an end offset of the current
  offset.
@end itemize

@item ; nonterminal-entry
@itemize @bullet
@item
  Read characters until a newline has been read. 
@item
  Add an entry to the end of the analysis vector with the current
  stack augmented with an entry for `comment-entry' with a start
  offset of the remembered offset and the end offset of the current
  offset.
@end itemize

@item ' nonterminal-entry
@itemize @bullet
@item
  Push an entry for quoted-expression-entry on the stack with a
  backquote-depth of one plus that of the current top of the stack.
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with an entry for `quote-entry' with a
  start offset of the remembered offset and an end offset of
  the current offset.  
@end itemize

@item ` nonterminal-entry
@itemize @bullet
@item
  Push an entry for quoted-expression-entry on the stack with a
  backquote-depth of that of the current top of the stack plus one.
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with an entry for `backquote-entry' with a
  start offset of the remembered offset and an end offset of
  the current offset.  
@end itemize

@item , nonterminal-entry
@itemize @bullet
@item
  If the backquote-depth of the top of the stack is greater than 0
@itemize @bullet
@item
    Push an entry for unquoted-expression-entry on the stack  with a
    backquote-depth of that of the current top of the stack minus
    one. 
@item
    Add an entry at the end of the analysis vector with the current
    stack augmented with an entry for `unquote-entry' with a
    start offset of the remembered offset and an end offset of
    the current offset.
@end itemize
@item
  Else
@itemize @bullet
@item
    Push an entry for unquoted-expression-entry on the stack  with a
    backquote-depth of 0.
@item
    Add an entry at the end of the analysis vector with the current
    stack augmented with an entry for `error-entry' with a start
    offset of the remembered offset and an end offset of the current
    offset.  
@end itemize
@end itemize

@item ( nonterminal-entry
@itemize @bullet
@item
  Push an entry for list-expression-entry on the stack with a
  backquote-depth of that of the current top of the stack.
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with an entry for `list-start-entry' with a
  start offset of the remembered offset and an end offset of
  the current offset.  
@end itemize

@item " nonterminal-entry
@itemize @bullet
@item
  Call the function associated with the character. 
  Increment the expression count of the top of the stack.    
@item
  Perform a count check (see below).
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with an entry for `string-entry' with a start
  offset of the remembered offset and an end offset of the current
  offset. 
@end itemize

@item # nonterminal-entry
@itemize @bullet
@item
  Remember the first char.
@item
  Read characters as long as they are digits, and form a count (a
  number or nil if there are no digits).
@item
  If the first non-digit character is a dispatch macro character
@itemize @bullet
@item
    Call parse-dispatch-macro-character with the buffer stream, the
    result of a call to get-dispatch-macro-character, the entry, and
    the remembered offset
@end itemize
@item
  Else 
@item
    Add an entry at the end of the analysis vector with the current
    stack augmented with an entry for `error-entry' with a start
    offset of the remembered offset and an end offset of the current
    offset.  
@end itemize

@item any nonterminal-entry
@itemize @bullet
@item
  Call the function associated with the character. 
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with an entry for `unknown-entry' with a start
  offset of the remembered offset and an end offset of the
  current offset. 
@end itemize
@end table

@deffn {Generic Function} parse-dispatch-macro-character buffer-stream function entry o
@end deffn

@table @samp
@item # nonterminal-entry
@itemize @bullet
@item
  Increment the expression count of the top of the stack.    
@item
  Perform a count check (see below).
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with an entry for `label-ref-entry' with a
  start offset of the remembered offset and an end offset of
  the current offset.  
@end itemize

@item ' nonterminal-entry
@itemize @bullet
@item
  Push an entry for function-expression-entry on the stack with a
  backquote-depth of that of the current top of the stack.
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with the entry for function-entry with a start
  offset of the remembered offset and the end offset of the current
  offset.  
@end itemize

@item ( nonterminal-entry
@itemize @bullet
@item
  Push an entry for vector-expression-entry on the stack with a
  backquote-depth of that of the current top of the stack.
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with the entry for vector-entry with a start offset
  of the remembered offset and the end offset of the current offset.
@end itemize

@item A nonterminal-entry
  [to be filled in]

@item = nonterminal-entry
@itemize @bullet
@item
  Push an entry for labeled-expression-entry on the stack with a
  backquote-depth of that of the current top of the stack.
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with the entry for label-entry with a start offset
  of the remembered offset and the end offset of the current offset. 
@end itemize

@item | nonterminal-entry
@itemize @bullet
@item
  Read characters until a |# pair has been seen or EOF is reached. 
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with the entry for balanced-comment-entry with a
  start offset of the remembered offset and the end offset of the
  current offset.
@end itemize

@item + nonterminal-entry
@itemx - nonterminal-entry
@itemize @bullet
@item
  Push an entry for read-time-conditional-expression-entry on the
  stack with a backquote-depth of that of the current top of the
  stack.  
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with the entry for read-time-conditional-entry with
  a start offset of the remembered offset and the end offset of the
  current offset.
@end itemize

@item . nonterminal-entry
@itemize @bullet
@item
  Push an entry for read-time-evaluation-expression-entry on the
  stack with a backquote-depth of that of the current top of the
  stack.
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with the entry for read-time-evaluation-entry with
  a start offset of the remembered offset and the end offset of the
  current offset.
@end itemize

@item any nonterminal-entry
@itemize @bullet
@item
  Call the function associated with the character. 
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with an entry for `unknown terminal' with a start
  offset of the remembered offset and an end offset of the
  current offset. 
@end itemize
@end table

@deffn {Generic Function} count-check nonterminal-entry

A count check means that we compare the expression count of the top of
the stack and its syntactic category.  If the category has a limited
number of expressions allowed, and we have reached it, we pop off the
top element, increment the expression count of the new top entry, and
perform a count check again.
@end deffn

@chapter The undo protocol

@section General

Undo is organized into a separate module.  This module conceptually
maintains a tree where the nodes represent application states and the
arcs represent transitions between these states.  The root of the
tree represents the initial state of the application.  The undo
module also maintains a current state.  During normal application
operation, the current state is a leaf of a fairly long branch of the
tree.  Normal application operations add new nodes to the end of this
branch.  Moving the current state up the tree corresponds to an undo
operation and moving it down some branch corresponds to some redo
operation.  

Arcs in the tree are ordered so that they always point FROM the
current state.  When the current state moves from one state to the
other, the arc it traversed is reversed.  The undo module does this
by calling a generic function that client code must supply a method
for. 

@deftp {error condition} no-more-undo

A condition of this type is signaled whenever an attempt is made to
call undo when the application is in its initial state. 
@end deftp

@deftp {protocol class} undo-tree

The base class for all undo trees. 
@end deftp

@deftp {protocol class} undo-record

The base class for all undo records.

Client code typically derives subclasses of this class that are
specific to the application. 
@end deftp

@deftp {initarg} :tree

Supplies the undo tree to which the undo record belongs. 
@end deftp

@deffn {generic function} add-undo undo-record undo-tree

Add an undo record to the undo tree below the current state, and set
the current state to be below the transition represented by the undo
record.
@end deffn

@deffn {generic function} flip-undo-record undo-record

This function is called by the undo module whenever the current state
is changed from its current value to that of the parent state
(presumably as a result of a call to undo) or to that of one of its
child states. 

Client code is required to supply methods for this function on
client-specific subclasses of undo-record. 
@end deffn

@deffn {generic function} undo undo-tree &optional (n 1)

Move the current state n steps up the undo tree and call
flip-undo-record on each step.  If the current state is at a level
less than n, a no-more-undo condition is signaled and the current
state is not moved (and no calls to flip-undo-record are made).

As long as no new record are added to the tree, the undo module
remembers which branch it was in before a sequence of calls to undo. 
@end deffn

@deffn {generic function} redo undo-tree &optional (n 1)

Move the current state n steps down the remembered branch of the undo
tree and call flip-undo-record on each step.  If the remembered
branch is shorter than n, a no-more-undo condition is signaled and
the current state is not moved (and no calls to flip-undo-record are
made). 
@end deffn

@section Implementation

Application states have no explicit representation, only undo records
do.  The current state is a pointer to an undo record (meaning, the
current state is BELOW the transition represented by the record) or to
the undo tree itself if the current state is the initial state of the
application. 

@section Suggested CLIM gadget

Undo might be presented in a CLIM gadget in the form of a tree where
branches are added to the right over time, in @xref{figundo}.


@image{undo}
@anchor{figundo} 

where the bigger black circle indicates the current state.  The tree
will be fairly tall and skinny, so the gadget should probably be a
tall, narrow window with scroll bars, and/or zoom.  The transitions
should be PRESENTed by client code so that a compact indication of the
type of record is used.  When the mouse is moved over a transition, a
more elaborate description is visible.

Clicking on any of the states generates calls to flip-undo-record for
every step the current state has to move in order to eventually arrive
at the state clicked on. 

@section How the buffer handles undo

@deftp {class} undoable-buffer

This is a subclass of standard-buffer.  Instantiating this class
creates an empy undo-tree for the buffer.
@end deftp

@deffn {generic function} undo-tree undoable-buffer

Return the undo-tree of the buffer. 
@end deffn

Undo is implemented as :after methods on, insert-buffer-object,
insert-buffer-sequence and delete-buffer-range specialized on
undoable-buffer.

@deftp {special variable} *undo-accumulate*

This variable is initially nil (the empty list).  The :after methods
on insert-buffer-object, insert-buffer-sequence, and
delete-buffer-range push undo records on to this list.
@end deftp

@deftp {special variable} *performing-undo*

This variable is initially nil.  The :after methods on
insert-buffer-object, insert-buffer-sequence, and delete-buffer-range
push undo records onto *undo-accumulate* only if *performing-undo* is
nil so that no undo information is added as a result of an undo
operation.
@end deftp

Three subclasses `insert-record', `delete-record', and
`compound-record' of undo-record are used.  An insert record stores a
position and some sequence of objects to be inserted, a delete record
stores a position and the length of the sequence to be deleted, and a
compound record stores a list of other undo records.

The :after methods on insert-buffer-object and insert-buffer-sequence
push a record of type delete-record onto *undo-accumulate*, and the
:after method on delete-buffer-range pushes a record of type
insert-record onto *undo-accumulate*.

@deffn {macro} with-undo buffer &body body

This macro first binds *undo-accumulate* to nil.  Then it executes
the forms of body.  Finally, it calls add-undo with an undo record
and the undo tree of the buffer.  If *undo-accumulate* contains a
single undo record, it is passed as is to add-undo.  If it contains
several undo records, a compound undo record is constructed out of
the list and passed to add-undo.  Finally, if *undo-accumulate* is
nil, add-undo is not called at all.
@end deffn

To avoid storing an undo record for each object that is inserted,
the with-undo macro may in some cases just increment the length of
the sequence in the last delete-record.

The method on flip-undo-record specialized on insert-record binds
*performing-undo* to t, inserts the sequence of objects in the
buffer, and calls change-class to convert the insert-record to a
delete-record, giving it a the length of the stored sequence.

The method on flip-undo-record specialized on delete-record binds
*performing-undo* to t, deletes the range from the buffer, and calls
change-class to convert the delete-record to an insert-record, giving
it the sequence at the stored offset in the buffer with the specified
length.

The method on flip-undo-record specialized on compound-record binds
*performing-undo* to t, recursively calls flip-undo-record on each
element of the list of undo records, and finally destructively
reverses the list.

@deftp {class} buffer-undo-record

A subclass of undo-record.
@end deftp

@deftp {initarg} :buffer

The buffer to which the record belongs. 
@end deftp

@deftp {initarg} :offset

This initarg is mandatory and supplies the offset that determines the
position at which the undo operation is to be executed.
@end deftp

@deffn {generic function} undo-offset undo-record

Return the offset of the undo record. 
@end deffn

@deftp {class} delete-record

A subclass of buffer-undo-record.  Whenever objects are inserted, a
delete-record containing a mark is created and added to the undo
tree.
@end deftp

@deftp {initarg} :length

Supply the length of the sequence of objects to be deleted whenever
flip-undo-record is called on an instance of delete-record.
@end deftp

@deftp {class} insert-record

A subclass of buffer-undo-record.  Whenever objects are deleted, the
sequence of objectgs is stored in an insert record containing a mark.
@end deftp

@deftp {initarg} :objects

Supply the sequence of objects that are to be inserted whenever
flip-undo-record is called on an instance of insert-record.
@end deftp

@deftp {class} compound-record

A subclass of buffer-undo-record.  This record simply contains a list
of other records.
@end deftp

@deftp {initarg} :records
@end deftp

@chapter Kill Ring Protocol

@section Overview

During the process of text editing it may become necessary for regions of text
to be manipulated non-sequentially.  The kill ring and its surrounding protocol
offers both a temporary location for data to be stored, as well as methods for 
stored data to be accessed.

Conceptually, the kill ring is a stack of bounded depth, so that when elements 
are pushed beyond that depth, the oldest element is removed.  All newly added 
data is attached to a single point at the ``start of ring position'' or SORP.

This protocol provides two methods which govern how data is to be attached to the 
SORP.  The first method moves the current SORP to a new position, on to which a new 
object is attached.  The second conserves the current position and replaces its 
contents with a sequence constructed of new and pre-existing SORP objects.  This 
latter method is refered to as a ``concatenating push''.

For data retrievial the kill ring class provides a ``yank point'' which
allows focus to be shifted from the SORP to other positions within the kill ring. 
The yank point is limited to two types of motition, one being a rotation away from the SORP 
and the other being an immediate return or ``reset'' to the start position.

@section General

@deftp {class} kill-ring
A class for all kill rings. 
@end deftp

@deftp {init-arg} :max-size
A limitation placed upon the number of elements held by a kill ring.  Once the maximum size 
has been reached, older entries must first be removed before new ones can be added.
@end deftp

@deffn {generic function} kill-ring-max-size kill-ring
Returns the value of a kill ring's maximum size.
@end deffn

@deffn {generic function} {(setf kill-ring-max-size)} kill-ring size
Alters the maximum size of a kill ring even if it means dropping
elements to do so.
@end deffn

@deffn {generic function} kill-ring-length kill-ring
Returns the current length of a kill-ring.  Note this is different than
kill-ring-max-size.
@end deffn

@deffn {generic function} kill-ring-standard-push kill-ring vector
Pushes a vector of objects onto a given kill ring creating a new start of ring 
position.  This function is much like an everyday lisp push with size considerations.  
If the length of the kill ring is greater than its maximum size, ``older'' elements 
will be removed from the ring until the maximum size is reached.
@end deffn

@deffn {generic function} kill-ring-concatenating-push kill-ring vector
Concatenates the contents of vector onto the end of the contents of
the current top of the kill-ring.  If the kill-ring is empty, a new
entry is pushed..
@end deffn

@deffn {generic function} rotate-yank-position kill-ring &optional times
Moves the yank point associated with a kill-ring one or times many positions
away from the start of ring position.  If times is greater than the current length 
then the cursor will wrap to the start of ring position and continue rotating.
@end deffn

@deffn {generic function} reset-yank-position kill-ring
Moves the current position of the yank point associated with a kill ring back to
the start of ring position.
@end deffn

@deffn {generic function} kill-ring-yank kill-ring &optional reset
Returns the vector of objects currently pointed to by the cursor.  If reset is T, then a 
call to reset-yank-position is called before the object is yanked.  The default for reset 
is NIL.
@end deffn

@section Implementation

The kill ring structure is built mainly of two parts: the stack like ring portion, which is 
a cursorchain, and the yank point, which is a left-sticky-flexicursor.
To initialize a kill ring, the :max-size slot initarg is simply used to set the max 
size.  The remaining slots constisting of the cursorchain and the left-sticky-flexicursor 
are instantized upon creation of the kill ring. 

Stored onto the cursorchain are simple-vectors of objects, mainly characters from a 
climacs buffer.  In order to facilitate this, the kill ring implementation borrows heavily from
the flexichain library of functions. The following functions lie outside the kill ring and 
flexichain protocols, but are pertinent to the kill ring implementation.

@deffn {accessor} kill-ring-chain kill-ring
A slot accessor provided by the Climacs implemention of the kill ring class, which returns the
cursorchain associated with kill-ring.
@end deffn

@deffn {accessor} kill-ring-cursor kill-ring
A slot accessor provided by the Climacs implemention of the kill ring class, which returns the
flexicursor assocated with kill-ring.
@end deffn

@node Index
@unnumbered Index

@printindex cp

@bye
